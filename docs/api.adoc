= React4xp: API Reference
:toc: right
:imagesdir: media/

image::react4xp.svg["React4xp logo",width=256px,link=index.html]
link:index.html[<- Back: React4xp technical reference]

This is an overview of the available runtime functionality in link:https://github.com/enonic/lib-react4xp[the React4xp library], v(REACT4XP_VERSION).

{nbsp} +
{nbsp} +
{nbsp} +

== XP controller functions

These functions are used in XP controllers, to handle React4xp entries and render output HTML (`body`) and activating `pageContributions`.

[NOTE]
====
*React4XP is built to _be contained_ in XP components, not to _contain_ them (for now).* So React4XP runtime should not:

- manipulate XP Regions,
- use Regions (or elements within Regions) as target containers,
- render any Region in the output `body`.

The safest and easiest way is ensure this:

- If you're using React4XP with a template that has a view, use a target container element that's separate from the region
- If you want React4XP to render something inside a Region (e.g. React-rendered _and_ drag-and-droppable content), let an XP Part handle the React4XP, and drop the part into the region as shown in link:https://developer.enonic.com/templates/react4xp[the intro tutorial].
====

{nbsp} +

=== Import
[source,javascript,options="nowrap"]
----
const React4xp = require('/lib/enonic/react4xp');

// Equivalent: import React4xp from '/lib/enonic/react4xp';
----

{nbsp} +

=== Easy: all-in-one renderer
[source,javascript,options="nowrap"]
----
React4xp.render(entry, props, request, params);

----

Main renderer and easiest usage. Default behavior: renders server-side and adds hydration logic for the client-side. On problems/errors, logs and falls back to a placeholder output which marks the problem on the page.

*Signature:*

- `entry` _(string|object, mandatory)_: Reference to the React4xp entry JSX file. Analogous to "view" parameter in the thymeleaf renderer etc. Can be a string or an object:
  * If it's a string, it's interpreted as a jsxPath.
  * If it's an object, it's interpreted as an XP component object from `portal.getComponent()`, and will be used to both find the JSX file and generate a unique ID (see also the params below).
- `props` _(object, optional)_: Sends props to the JSX file. Analogous to "model" parameter in the thymeleaf renderer etc.
- `request` _(object, optional-ish)_: XP request object (from controller get-method etc). *Mandatory for proper React rendering*, but strictly speacking optional. If omitted...
  * the rendering will fall back to a template-like JSX rendering: outputs a static HTML string using the props,
  * and it will not be activated/hydrated in the client.
- `params` _(object, optional)_: Additional parameters controlling the React rendering. Each of them are optional within the params object:


*Params:*

- `clientRender` _(boolean)_: Controls server-side vs client-side rendering (as long as a `request` argument is given, see above).
  * if this parameter is missing or falsy then server-side rendering (SSR) is the default behavior, and a static HTML string is rendered as output, and react `hydrate()` pageContributions are added.
  * If set to `true`, however, client-side rendering is forced: only a target container with an element ID is rendered in the output, but react `render()` pageContributions are added.
- `id` _(string)_: sets the target container element ID (by force - if an ID was generated from an XP-component-type `entry` argument earlier, this manual ID will override the generated one). If no ID is set or generated from an in-XP-component entry, a random unique ID is generated. Also:
      *         If the ID matches a DOM element ID in an input `body` (see below), the rendered react component will be inserted in that element.
      *         If not, a container with this ID will be added.
      *         If there's no `body` parameter at all, an HTML string with a matching-ID element is generated.
- `uniqueId` _(boolean|string)_: If set, takes an extra step to ensure a unique ID:
      *         If an ID is already set (by previous param or using an XP-component-object entry), a random integer will be postfixed to it.
      *         If `uniqueId` is a string, this is the prefix before the random postfix. If the id param is used in addition to a `uniqueId` string, `uniqueId` takes presedence and overrides `id`.
- `body` _(string)_: HTML string, for example a static string, or previously rendered from other react4xp output, thymeleaf or other templating engines.
      *         If it already has a matching-ID target container, `body` passes through unchanged (use this option and the set the ID to control where in a `body` the react component should be rendered).
      *         If it doesn't have a matching container, a matching `<div>` will be inserted at the end of the body, inside the root element.
      *         If `body` is missing, a pure-target-container body is generated and returned.
- `pageContributions` _(object)_: Pre-existing pageContributions. If added, page contributions generated during this rendering will be added to (merged with) the input parameter ones.

*Return:*

`render` returns a response object that can be directly returned from an XP controller, with the fields `body` and `pageContributions`: `body` will always contain at least a target container element for the react component. `pageContributions` will contain scripts referred by URL for running the react component client-side and the component's dependencies, as well as an inline trigger script for starting the react frontend rendering into the target container. Duplicates in `pageContributions` will be removed, to avoid running identical scripts twice.


{nbsp} +

=== Flexible: react4xp objects

==== Construction

[source,javascript,options="nowrap"]
----
const comp = new React4xp(component|jsxPath);
----

*Signature:*

The constructor has a mandatory parameter, _one_ of the following two. This follows the same logic as the `component` and `jsxPath` subfields in `params` in the shorthand rendering methods above:

  * *Either* `component` _(object)_ Current-XP-component data; the output of `portal.getComponent()`. This will point to a local (same-name, same-folder as the component) react file. Derives and sets the component's `jsxPath` and its `id` (`react4xpId`) so they don't need to be set.
  * *Or* `jsxPath` _(string)_ Pointer to any component. Sets the component's `jsxPath` but not the `id`.

*Returns:*

The constructed data-holding object (called `comp` below).

{nbsp} +

==== Setters and attributes

The constructed object has some *setter methods*:

[source,javascript,options="nowrap"]
----
comp.setProps(props); <!--1-->
comp.setJsxPath(jsxPath); <!--2-->
comp.setId(id); <!--3-->
comp.uniqueId(); <!--4-->

/*
Sequence doesn't matter (except for setId,
which can overwrite a previous uniqueId).
Each setter returns the object itself,
enabling a Builder pattern. So this would
be equivalent to the above:

comp.setProps(props)
	.setJsxPath(jsxPath)
	.setId(id)
	.uniqueId();

*/
----

<1> `setProps(props)`: Sets the react4xp object's top-level props, which will be fed to the entry component. `props` _(object)_ is any object fully serializable by `JSON.stringify`. Functions can't be passed as top-level props. Overwrites previous props. Even if not set explicitly, the props received by the entry component will always contain the ID, as `react4xpId`.
<2> `setJsxPath(jsxPath)`: `jsxPath` _(string)_ points to an entry component that must exist, jsxPath must be valid. Overwrites previous value.
<3> `setId(id)`: `id` _(string)_ Identifies the react4xp component (`comp`) and points to a target container in the DOM to receive the react rendering. Preferrably a unique element `id` in the DOM. Corresponds to `comp.react4xpId` and `props.react4xpId`.
<4> `uniqueId()`: enforces a unique target-element and entry ID, by appending a random-number postfix. If an ID hasn't been set, it will become the random-number postfix.

The setters correspond to these *readable attributes* in the object:

[source,javascript,options="nowrap"]
----
comp.props <!--1-->
comp.jsxPath <!--2-->
comp.react4xpId <!--3-->
----
<1> `props` _(object)_ React props passed to the entry.
<2> `jsxPath` _(string)_ The jsxPath of the target react entry. The entry must exist.
<3> `react4xpId` _(string)_ ID of the entry and the target container element - if set (see below). If not set, the rendering methods will generate a random ID (and a matching target container).


==== Rendering the react4xp data object

HTML body and page contributions are rendered separately here. *Both are necessary* for react rendering to work properly:

[source,javascript,options="nowrap"]
----
const body = comp.renderBody(params); <!--1-->
const pageContributions = comp.renderPageContributions(params); <!--2-->

/*
Ready to return from an XP controller:

return { body, pageContributions };
*/
----

<1> `renderBody` generates an HTML rendering of the data object, or adds a rendering to other HTML. Returns an HTML string (ready to be returned as `body` in a controller's response object, or passed though yet another React4xp data oject's `renderBody` method). There will always be an output HTML with a matching-ID target container, but you can use the `body` parameter to add custom pre-existing HTML around what's rendered here. `params` _(optional object)_ can contain additional optional parameters controlling the react rendering:
* `body` _(string)_: Pre-existing HTML string that will be passed through this rendering. The new rendered HTML will be inserted into `body`, by these rules: If `body` has one element whose ID matches the ID of this react4xp object (`react4xpId`), that element will be the target container element for this rendering. If there is no matching ID, a new target container (with an ID matching `react4xpId`) will be generated at the end of `body`. If no `body` is entered at all, a new HTML with a matching-ID target container is generated.
* `clientRender` _(boolean)_: if `clientRender` is falsy or unset, there will be a server-side rendering: a static HTML string is rendered from the data object (and its React code and props), and this HTML is inserted into the target container. If `clientRender` is truthy, the target container is left empty - ready to be filled in a client-side rendering (see below. For this reason, the `clientRender`  value should usually match between `renderBody` and `renderPageContributions`).
<2> `renderPageContributions` generates and returns XP page contributions. These page contributions activate the React entry in the client (whether it's triggering a client-side rendering or hydrating a server-side rendered entry). More precisely: adds client-side dependency chunks (core React4xp frontend, shared libs and imported react components, and the entry scripts), adds small scripts that trigger the entry scripts, and prevents duplicate references to dependencies. `params` _(optional object)_ are additional parameters to control the react rendering:
* `pageContributions` _(object)_: pre-existing page contributions object to pass through this rendering. These pre-existing page contributions will be added at the beginning of the rendered output pageContributions.
* `clientRender` _(boolean)_: If falsy or unset, server-side rendering is assumed, and a `hydrate` command is called on the entry instead. If `clientRender` is truthy, this function will assume that the react4xp entry is being rendered (by `renderBody`) client-side instead of server-side, and only calls a `render` command in the client.

[NOTE]
====
*Rendering the data object is different from the `React4xp.render` link:#_easy_all_in_one_renderer[all-in-one method] in a few ways:*

* First, the rendering methods expect the data-object attributes to be completely set before rendering, instead of passing them to the render method as attributes.
* Second, it doesn't automatically handle the `request` to keep Content Studio and the React client code from interfering with each other, but leaves it up to you (link:#TODO[read more about how here]).
* Third, instead of rendering a full response object, it renders the HTML body and the page contributions separately
====

{nbsp} +
{nbsp} +

== Services
The React4xp lib exposes four link:https://xp.readthedocs.io/en/stable/developer/services/index.html[XP services] that can be used from the client. The controller functions render page contributions that call on these services, so in most cases you don't need to worry about this, but the service specs look like this:

{nbsp} +

=== Fetch static assets: `/react4xp`

The `/react4xp` service returns JS assets needed to run your react4xp entries in the browser. The assets can be either entries or dependency chunks, after webpack compilation.

*Access:*
[source]
----
[domain]/_/service/[appName]/react4xp/[assetName]
----
...or from Thymeleaf:
[source,html,options="nowrap"]
----
<script data-th-src="${portal.serviceUrl({'_service=react4xp/[assetName]'})}"></script>
----

*Parameters:*

`[assetName]` is the name of the _compiled_ file, relative to the React4xp build folder (`build/resources/main/assets/react4xp/`). This is the reason for _rendering_ these page contributions: that process handles all differences in file names across the compilation, as well as auto-tracking each dependency. For entry files, `assetName` will be the same as the _jsxPath_, with `.js` at the end.

*Example*

On the app _my.app_ running on _mydomain.com_, `www.mydomain.com/_/service/my.app/react4xp/myEntry.js` would look for and return the compiled entry `myEntry` - originally `myEntry.jsx`.

*Errors:*

If nothing was found on `assetName`, the response will be a `404 - Not Found`.

{nbsp} +

=== Dependency tracking: `/react4xp-dependencies`

The `/react4xp-dependencies` service *returns* a JSON array of all asset URLs for dependency chunks that a list of entries need to run, between them. In a browser, these should of course be fetched and run _before the entry assets themselves_. Each asset in the array will be unique, preventing repeated and excessive loading. Dependecy chunks are content hashed in their file names, prepared for client-caching when fetched from the `/react4xp` service.

[NOTE]
====
The returned list of dependencies _do not include externals_: by default *React and ReactDOM are not included in the list.* They need to be added separately!

For this, simply add CDN urls, or you can use the `/react4xp-externals` service (see below).
====

The general idea is: for a collection of entries, a single call to `/react4xp-dependencies` will tell you which additional assets are needed for them to run. Use the returned URLs directly to fetch them, then fetch the entries with the `/react4xp` service. Don't forget the externals!


*Access:*
[source]
----
[domain]/_/service/[appName]/react4xp-dependencies?[entryNameOrNames]

A slash instead of question mark is also possible:

[domain]/_/service/[appName]/react4xp-dependencies/[entryNameOrNames]
----
...or in Thymeleaf, similarly to `/react4xp` above.

*Parameters:*

`[entryNameOrNames]` is one or more jsxPaths to React4xp entries, separated by ampersand `&`.

*Example:*

If the entries `myFirstEntry.jsx` and `mySubfolder/mySecondEntry.jsx` both import code from `myChunk/myDependency.es6`, the imported code will be compiled into `myChunk` with a content hash - e.g. `myChunk.eb2abe4fac.js`. Then, calling the service with...
[source]
====
`www.mydomain.com/_/service/my.app/react4xp-dependencies?myFirstEntry&mySubfolder/mySecondEntry`
====
...will return this `application/json` response:

[source,json,options="nowrap"]
----
[
	"www.mydomain.com/_/service/my.app/react4xp/myChunk.eb2abe4fac.js"
]
----

*Errors:*

If one or mores of the entries in `[entryNameOrNames]` were not found (as compiled files under `build/resources/main/assets/react4xp/`), the service will return 404 and a diagnostic response.

[TIP]
====
Jump here for link:#TODO[more info about entries, chunks and compilation].
====


{nbsp} +

=== Fetch React/ReactDOM: `/react4xp-externals`

React4xp offers React and ReactDOM out of the box on this service endpoint. Fetching and running this single call will make them available in the browser's global namespace for React4xp entries _and_ for other React components outside of React4xp (that's what externals are).

Using this service is equivalent to using CDN urls, but with two differences: it's served from XP, and has the added benefit of always being the same React/-DOM versions as the server is using for server-side rendering - ensuring completely isomorphic code. You control which React/-DOM versions are used by adding them to your project's `package.json`, under `dependencies`.

If you want more control over what is served as externals from this service, it must be done during the build. Manipulate the `EXTERNALS` parameter in the link:https://www.npmjs.com/package/react4xp-buildconstants[react4xp-buildconstants] step of your build.

*Example:*
[source,html5,options="nowrap"]
----
<html>
  <head>
    <script src="www.mydomain.com/_/service/my.app/react4xp-externals"></script>
  </head>

  <body>
    <script>
      // React and ReactDOM are now available to scripts
    </script>
  </body>
</html>
----


{nbsp} +

=== Fetch the client wrapper: `/react4xp-client`

This service fetches some global JS helper functions that's made available to the global namespace in the browser, under `React4xp.CLIENT`. The link:#_client_side_wrapper_api[client wrapper API] is described below.

*Example:*
[source,html5,options="nowrap"]
----
<html>
  <head>
    <script src="www.mydomain.com/_/service/my.app/react4xp-client"></script>
  </head>

  <body>
    <script>
      console.log( Object.keys( React4xp.CLIENT ));

      // Output to the console:
      // ['render', 'hydrate', 'renderWithDependencies']

    </script>
  </body>
</html>
----


{nbsp} +
{nbsp} +
{nbsp} +

== Client-side wrapper API
Downloadable from link:#_fetch_the_client_wrapper_code_react4xp_client_code[the `/react4xp-client` service], is client-runnable code that wraps a few handy functions, used by the autogenerated pageContributions, but usable manually as well.

It creates a `React4xp` global object in the browser, which will contain all things React4xp. It exposes three methods under the `React4xp.CLIENT` attribute:

.Client-side wrapper functions:
[source,javascript,options="nowrap"]
----
React4xp.CLIENT.render(Entry, targetId [, props] ); // corresponds to https://reactjs.org/docs/react-dom.html#render

React4xp.CLIENT.hydrate(Entry, targetId [, props] ); // corresponds to https://reactjs.org/docs/react-dom.html#hydrate

React4xp.CLIENT.renderWithDependencies(entriesTargetsAndProps [, callback [, serviceUrlRoot]] );
----

The first two methods are 'pure' renderers. This means that in addition to the client wrapper, you need to supply and run scripts for React and ReactDOM (which are bundled in the React4xp _externals_) - and scripts for the entries as well as all their chunks, before calling `render` or `hydrate`.

However, you can also use React4xp entries in a standalone html page, having only React/ReactDOM (or React4xp externals) and this client loaded in the browser: use `renderWithDependencies` as below.

{nbsp} +

=== `render` and `hydrate`
Both functions have the same signature:

`(Entry, targetId [, props])`

  * `Entry`: _(React4xp entry or any React renderable, mandatory)_ If this is a function, the wrapper will try to turn it into a React component by running `Entry(props)`. When loading React4xp entries, they are exposed in the client as function attributes of the `React4xp` object: `React4xp[jsxPath] = (props) => ReactComponent`.
    - A fallback has been added so that if an entry has been compiled into a `.default` sub-attribute, the client can access the entry both with and without the `default` field: if `React4xp.CLIENT.render(React4xp['myEntry'].default, ...)` is strictly correct, then `React4xp.CLIENT.render(React4xp['myEntry'], ...)` will also work.
  * `targetId` _(string, mandatory)_ The unique ID of an HTML container element, into which the entry will be rendered. Obviously, this must exist in the DOM when running.
  * `props`: _(object, optional)_ Top-level props that will be sent into the entry. React4xp relies on serialization of the props object. Make it serializable.

*Example:*
[source,html5,options="nowrap"]
----
  <script defer>
      React4xp.CLIENT.render(
          React4xp.ColorThing,
          'target_container',
          {color: "crimson"}
      );
      React4xp.CLIENT.hydrate(
          React4xp['site/parts/serverSideRenderedEntry/serverSideRenderedEntry'],
          'other_container'
      );
  </script>
----

{nbsp} +

=== `renderWithDependencies`
This function is not used in the rendering from the controller, but is an auxillary rendering method for manually rendering React4xp-compiled entries from the client. It wraps a whole chain of necessary steps: when you have one or more React4xp entries you want to render and you know their jsxPaths and props, then `React4xp.CLIENT.renderWithDependencies` will take care of the gritty details - in a single call for multiple React4xp entries:

  - contact the React4xp services,
  - determine what the entries' chunk dependencies are,
  - download and run those in parallel,
  - then download and run the entry scripts,
  - then run `render` on each of the entries,
  - all the time preventing duplicate downloads.

*Service root URL:*

There is one caveat: `renderWithDependencies` needs to know the root path to the React4xp services:

----
[domain]/_/service/[appName]/
----

In all the examples for the services above, the service root URL would be `/_/service/my.app/`. As you see below, you can choose to add it by a parameter or a global variable before the call. This is equal to `portal.serviceUrl({'_service='})`, by the way.

*Parameters:*

  * `entriesTargetsAndProps` _(object, mandatory)_ Object where each entry is similar to the `Entry, targetId, [, props]` signature mentioned above: the *keys*  are jsxPath strings of React4xp entries. The *values* are objects that have a mandatory `targetId` string and an optional `props` object.
  * `callback` _(function, optional)_ This function is run after running `render`,
  * `serviceUrlRoot` _(string, mandatory-ish)_ Root of the URL to the `/react4xp` and `/react4xp-dependencies` link:#\_services[services]. This parameter is "sort of optional": you can skip it if you define a global constant `SERVICE_URL_ROOT` before running  `renderWithDependencies`. If you don't, it's mandatory.

*Example:*
[source,html5,options="nowrap"]
----
<script>
    React4xp.CLIENT.renderWithDependencies(
        {
            ColorThing: {
                targetId: 'target_container',
                props: { color: "crimson"}
            },

            'site/parts/chaining/chaining': {
                targetId: 'clickable_thing',
                props: { first: "Come On!", second: "Click Me Already!" },
            },
        },

        // Callback:
        function() { console.log("This callback is inserted and called after rendering."); },

        '/_/service/my.app'
    );
</script>
----

{nbsp} +
{nbsp} +

=== Example: everything in context

Just to demonstrate how everything fits together on the client side, here's a stripped-down Thymeleaf example.

This is *standalone*, in the sense that it doesn't use any XP controllers but will run like this in an XP context (given the compiled entries `ColorThing` and `site/parts/chaining/chaining`, of course):

[source,thymeleafexpressions,options="nowrap"]
----
<html>
  <head>
    <script data-th-text="|var SERVICE_URL_ROOT=`${portal.serviceUrl({'_service='})}`;|"></script> <!--1-->

    <script data-th-src="${portal.serviceUrl({'_service=react4xp-externals'})}"></script> <!--2-->
    <script data-th-src="${portal.serviceUrl({'_service=react4xp-client'})}"></script> <!--3-->
  </head>

  <body>
    <div id="color_thing"></div>  <!--4-->
    <div id="clickable_thing"></div>

    <script>
      React4xp.CLIENT.renderWithDependencies(  <!--5-->
        {
            ColorThing: {
                targetId: 'color_thing',
                props: { color: "crimson"}
            },

            'site/parts/chaining/chaining': {
                targetId: 'clickable_thing',
                props: { title: "Come On!", text: "Click Me Already!" },
            },
        }
      );
    </script>
  </body>
</html>
----


That's it. *What happened there?*

<1> `SERVICE_ROOT_URL` is resolved and set globally.
<2> React and ReactDOM are made available...
<3> ...and so is the React4xp client wrapper.
<4> Target container elements are set up. Empty for now, but rendering will fill these up.
<5> Next, `renderWithDependencies` goes to work:

Let's say the entries `ColorThing` and `site/parts/chaining/chaining` had two compiled dependencies between them, `chunk1.js` and `chunk2.js`. And let's say `SERVICE_URL_ROOT` in the beginning was resolved to `/_/service/my.app/`.

The `renderWithDependencies` function just wraps the functionality that the XP controller functions handle. So it would first fetch...

====
/_/service/my.app/react4xp-dependencies?ColorThing&site/parts/chaining/chaining
====

...to see what the entries need to run. It would then use the reponse to populate the DOM with the dependency assets:

[source,html5,options="nowrap"]
----
  <script url="/_/service/my.app/react4xp/chunk1.js"></script>
  <script url="/_/service/my.app/react4xp/chunk2.js"></script>
----

Next, it populates the DOM with the entry assets:

[source,html5,options="nowrap"]
----
  <script url="/_/service/my.app/react4xp/ColorThing.js"></script>
  <script url="/_/service/my.app/react4xp/site/parts/chaining/chaining.js"></script>
----

And finally it populates the DOM with the rendering trigger calls (which again are abstractions of some more basic React calls:

[source,html5,options="nowrap"]
----
  <script defer>
      React4xp.CLIENT.render(
          React4xp.ColorThing,
          'color_thing',
          {color: "crimson"}
      );

      React4xp.CLIENT.render(
          React4xp['site/parts/chaining/chaining'],
          'clickable_thing',
          { title: "Come On!", text: "Click Me Already!" }
      );
  </script>
----

And finally, we're skipping the optional callback function in `renderWithDependencies`. No service root URL parameter is needed either, since `SERVICE_URL_ROOT` was defined earlier.

{nbsp} +
{nbsp} +

== TODO

Add API doc under link:http://127.0.0.1:5050/api.html#_flexible_react4xp_objects[react4xp objects], for renderEntryToHtml (lib/enonic/react4xp/index.es6:307, #React4xp.renderEntryToHtml)
