= React4xp: API Reference
:toc: right
:imagesdir: media/

image::react4xp.svg["React4xp logo",width=256px,link=index.html]
link:index.html[<- Back: React4xp technical reference]

This is an overview of the available runtime functionality in link:https://github.com/enonic/lib-react4xp[the React4xp library], v(REACT4XP_VERSION).

{nbsp} +
{nbsp} +
{nbsp} +

== XP controller functions

These functions are used in XP controllers, to handle React4xp entries and render output HTML (`body`) and activating `pageContributions`.

[NOTE]
====
*React4XP is built to _be contained_ in XP components, not to _contain_ them (for now).* So React4XP runtime should not:

- manipulate XP Regions,
- use Regions (or elements within Regions) as target containers,
- render any Region in the output `body`.

The safest and easiest way is ensure this:

- If you're using React4XP with a template that has a view, use a target container element that's separate from the region
- If you want React4XP to render something inside a Region (e.g. React-rendered _and_ drag-and-droppable content), let an XP Part handle the React4XP, and drop the part into the region as shown in link:https://developer.enonic.com/templates/react4xp[the intro tutorial].
====

{nbsp} +

=== Import
[source,javascript,options="nowrap"]
----
const React4xp = require('/lib/enonic/react4xp');

// Equivalent: import React4xp from '/lib/enonic/react4xp';
----

{nbsp} +

=== Easy: all-in-one renderer
[source,javascript,options="nowrap"]
----
React4xp.render(entry, props, request, params);

----

Main renderer and easiest usage. Default behavior: renders server-side and adds hydration logic for the client-side. On problems/errors, logs and falls back to a placeholder output which marks the problem on the page.

*Signature:*

- `entry` _(string|object, mandatory)_: Reference to the React4xp entry JSX file. Analogous to "view" parameter in the thymeleaf renderer etc. Can be a string or an object:
  * If it's a string, it's interpreted as a jsxPath.
  * If it's an object, it's interpreted as a component object from `portal.getComponent()`, and will be used to both find the JSX file and generate a unique ID (see also the params below).
- `props` _(object, optional)_: Sends props to the JSX file. Analogous to "model" parameter in the thymeleaf renderer etc.
- `request` _(object, optional-ish)_: XP request object (from controller get-method etc). *Mandatory for proper React rendering*, but strictly speacking optional. If omitted...
  * the rendering will fall back to a template-like JSX rendering: outputs a static HTML string using the props,
  * and it will not be activated/hydrated in the client.
- `params` _(object, optional)_: Additional parameters controlling the React rendering. Each of them are optional within the params object:


*Params:*

- `clientRender` _(boolean)_: Controls server-side vs client-side rendering (as long as a `request` argument is given, see above).
  * if this parameter is missing or falsy then server-side rendering (SSR) is the default behavior, and a static HTML string is rendered as output, and react `hydrate()` pageContributions are added.
  * If set to `true`, however, client-side rendering is forced: only a target container with an element ID is rendered in the output, but react `render()` pageContributions are added.
- `id` _(string)_: sets the target container element ID (by force - if an ID was generated from a component-type `entry` argument earlier, this manual ID will override the generated one). If no ID is set or generated from a component entry, a random unique ID is generated. Also:
      *         If the ID matches a DOM element ID in an input `body` (see below), the rendered react component will be inserted in that element.
      *         If not, a container with this ID will be added.
      *         If there's no `body` parameter at all, an HTML string with a matching-ID element is generated.
- `uniqueId` _(boolean|string)_: If set, takes an extra step to ensure a unique ID:
      *         If an ID is already set (by previous param or using a component-object entry), a random integer will be postfixed to it.
      *         If `uniqueId` is a string, this is the prefix before the random postfix. If the id param is used in addition to a `uniqueId` string, `uniqueId` takes presedence and overrides `id`.
- `body` _(string)_: HTML string, for example a static string, or previously rendered from other react4xp output, thymeleaf or other templating engines.
      *         If it already has a matching-ID target container, `body` passes through unchanged (use this option and the set the ID to control where in a `body` the react component should be rendered).
      *         If it doesn't have a matching container, a matching `<div>` will be inserted at the end of the body, inside the root element.
      *         If `body` is missing, a pure-target-container body is generated and returned.
- `pageContributions` _(object)_: Pre-existing pageContributions. If added, page contributions generated during this rendering will be added to (merged with) the input parameter ones.

*Return:*

`render` returns a response object that can be directly returned from an XP controller, with the fields `body` and `pageContributions`: `body` will always contain at least a target container element for the react component. `pageContributions` will contain scripts referred by URL for running the component client-side and the component's dependencies, as well as an inline trigger script for starting the react frontend rendering into the target container. Duplicates in `pageContributions` will be removed, to avoid running identical scripts twice.


{nbsp} +

=== Flexible: react4xp objects

==== Construction

[source,javascript,options="nowrap"]
----
const comp = new React4xp(component|jsxPath);
----

*Signature:*

The constructor has a mandatory parameter, _one_ of the following two. This follows the same logic as the `component` and `jsxPath` subfields in `params` in the shorthand rendering methods above:

  * *Either* `component` _(object)_ Current-XP-component data; the output of `portal.getComponent()`. This will point to a local (same-name, same-folder as the component) react file. Derives and sets the component's `jsxPath` and its `id` (`react4xpId`) so they don't need to be set.
  * *Or* `jsxPath` _(string)_ Pointer to any component. Sets the component's `jsxPath` but not the `id`.

*Returns:*

The constructed data-holding object (called `comp` below).

{nbsp} +

==== Setters and attributes

The constructed object has some *setter methods*:

[source,javascript,options="nowrap"]
----
comp.setProps(props); <!--1-->
comp.setJsxPath(jsxPath); <!--2-->
comp.setId(id); <!--3-->
comp.uniqueId(); <!--4-->

/*
Sequence doesn't matter (except for setId,
which can overwrite a previous uniqueId).
Each setter returns the object itself,
enabling a Builder pattern. So this would
be equivalent to the above:

comp.setProps(props)
	.setJsxPath(jsxPath)
	.setId(id)
	.uniqueId();

*/
----

<1> `setProps(props)`: Sets the react4xp object's top-level props, which will be fed to the entry component. `props` _(object)_ is any object fully serializable by `JSON.stringify`. Functions can't be passed as top-level props. Overwrites previous props. Even if not set explicitly, the props received by the entry component will always contain the ID, as `react4xpId`.
<2> `setJsxPath(jsxPath)`: `jsxPath` _(string)_ points to an entry component that must exist, jsxPath must be valid. Overwrites previous value.
<3> `setId(id)`: `id` _(string)_ Identifies the react4xp component (`comp`) and points to a target container in the DOM to receive the react rendering. Preferrably a unique element `id` in the DOM. Corresponds to `comp.react4xpId` and `props.react4xpId`.
<4> `uniqueId()`: enforces a unique element and component ID, by appending a random-number postfix. If an ID hasn't been set, it will become the random-number postfix.

The setters correspond to these *readable attributes* in the object:

[source,javascript,options="nowrap"]
----
comp.props <!--1-->
comp.jsxPath <!--2-->
comp.react4xpId <!--3-->
----
<1> `props` _(object)_ React props passed to the entry.
<2> `jsxPath` _(string)_ The jsxPath of the target react entry. The entry must exist.
<3> `react4xpId` _(string)_ Component and target-container ID, if set (see below). If not set, the rendering methods will generate a random ID.


==== Rendering the react4xp data object

HTML body and page contributions are rendered separately here. *Both are necessary* for react rendering to work properly:

[source,javascript,options="nowrap"]
----
const body = comp.renderBody(params); <!--1-->
const pageContributions = comp.renderPageContributions(params); <!--2-->

/*
Ready to return from an XP controller:

return { body, pageContributions };
*/
----

<1> `renderBody` generates an HTML rendering of the data object, or adds a rendering to other HTML. Returns an HTML string (ready to be returned as `body` in a controller's response object, or passed though yet another React4xp data oject's `renderBody` method). There will always be an output HTML with a matching-ID target container, but you can use the `body` parameter to add custom pre-existing HTML around what's rendered here. `params` _(optional object)_ can contain additional optional parameters controlling the react rendering:
* `body` _(string)_: Pre-existing HTML string that will be passed through this rendering. The new rendered HTML will be inserted into `body`, by these rules: If `body` has one element whose ID matches the ID of this react4xp object (`react4xpId`), that element will be the target container element for this rendering. If there is no matching ID, a new target container (with an ID matching `react4xpId`) will be generated at the end of `body`. If no `body` is entered at all, a new HTML with a matching-ID target container is generated.
* `clientRender` _(boolean)_: if `clientRender` is falsy or unset, there will be a server-side rendering: a static HTML string is rendered from the data object (and its React code and props), and this HTML is inserted into the target container. If `clientRender` is truthy, the target container is left empty - ready to be filled in a client-side rendering (see below. For this reason, the `clientRender`  value should usually match between `renderBody` and `renderPageContributions`).
<2> `renderPageContributions` generates and returns XP page contributions. These page contributions activate the React entry in the client (whether it's triggering a client-side rendering or hydrating a server-side rendered entry). More precisely: adds client-side dependency chunks (core React4xp frontend, shared libs and components, and the entry component scripts), adds small scripts that trigger the component scripts, and prevents duplicate references to dependencies. `params` _(optional object)_ are additional parameters to control the react rendering:
* `pageContributions` _(object)_: pre-existing page contributions object to pass through this rendering. These pre-existing page contributions will be added at the beginning of the rendered output pageContributions.
* `clientRender` _(boolean)_: If falsy or unset, server-side rendering is assumed, and a `hydrate` command is called on the entry instead. If `clientRender` is truthy, this function will assume that the react4xp entry is being rendered (by `renderBody`) client-side instead of server-side, and only calls a `render` command in the client.

[NOTE]
====
*Rendering the data object is different from the `React4xp.render` link:#_easy_all_in_one_renderer[all-in-one method] in a few ways:*

* First, the rendering methods expect the data-object attributes to be completely set before rendering, instead of passing them to the render method as attributes.
* Second, it doesn't automatically handle the `request` to keep Content Studio and the React client code from interfering with each other, but leaves it up to you (link:#TODO[read more about how here]).
* Third, instead of rendering a full response object, it renders the HTML body and the page contributions separately
====

{nbsp} +
{nbsp} +

== Services
The React4xp lib exposes four link:https://xp.readthedocs.io/en/stable/developer/services/index.html[XP services] that can be used from the client. The controller functions render page contributions that call on these services, so in most cases you don't need to worry about this, but the service specs look like this:

{nbsp} +

=== Fetching static assets: `/react4xp`

The `/react4xp` service returns JS assets needed to run your react components in the browser. The assets can be either entries or dependency chunks, after webpack compilation.

*Access:*
[source]
----
[domain]/_/service/[appName]/react4xp/[assetName]
----
...or from Thymeleaf:
[source,html,options="nowrap"]
----
<script data-th-src="${portal.serviceUrl({'_service=react4xp/[assetName]'})}"></script>
----

*Parameters:*

`[assetName]` is the name of the _compiled_ file, relative to the React4xp build folder (`build/resources/main/assets/react4xp/`). This is the reason for _rendering_ these page contributions: that process handles all differences in file names across the compilation, as well as auto-tracking each dependency. For entry files, `assetName` will be the same as the _jsxPath_, with `.js` at the end.

*Example*

On the app _my.app_ running on _mydomain.com_, `www.mydomain.com/_/service/my.app/react4xp/myEntry.js` would look for and return the compiled entry `myEntry` - originally `myEntry.jsx`.

*Errors:*

If nothing was found on `assetName`, the response will be a `404 - Not Found`.

{nbsp} +

=== Dependency tracking: `/react4xp-dependencies`

The `/react4xp-dependencies` service *returns* a JSON array of all asset URLs for dependency chunks that a list of entries need to run, between them. In a browser, these should of course be fetched and run _before the entry assets themselves_. Each asset in the array will be unique, preventing repeated and excessive loading. Dependecy chunks are content hashed in their file names, prepared for client-caching when fetched from the `/react4xp` service (which is the natural next step).

*Access:*
[source]
----
[domain]/_/service/[appName]/react4xp-dependencies?[entryNameOrNames]

A slash instead of question mark is also possible:

[domain]/_/service/[appName]/react4xp-dependencies/[entryNameOrNames]
----
...or in Thymeleaf, similarly to `/react4xp` above.

*Parameters:*

`[entryNameOrNames]` is one or more jsxPaths to React4xp entries, separated by ampersand `&`.

*Example:*

If the entry `myFirstEntry.jsx` and `mySecondEntry.jsx` both import code from `myChunk/myDependency.es6`, the imported code will be compiled into `myChunk` with a content hash - e.g. `myChunk.eb2abe4fac.js`. Then, calling the service with...
[source]
====
`www.mydomain.com/_/service/my.app/react4xp-dependencies/myFirstEntry&mySecondEntry`
====
...will return this `application/json` response:

[source,json,options="nowrap"]
----
[
	"www.mydomain.com/_/service/my.app/react4xp/myChunk.eb2abe4fac.js"
]
----

*Errors:*

If one of the entries in `[entryNameOrNames]` were not found (as compiled files under `build/resources/main/assets/react4xp/`), the service will return 404 and a diagnostic response.

[TIP]
====
Jump here for link:#TODO[more info about entries, chunks and compilation].
====




{nbsp} +

== Client-side wrapper
Downloadable from the `/react4xp-client` service, is client-runnable code that wraps a few handy functions, used by the autogenerated pageContributions, but usable manually as well.

It creates a `React4xp` global object in the browser, which will contain all things React4xp. It exposes three methods under the `React4xp.CLIENT` attribute:

.Client-side wrapper functions:
[source,javascript,options="nowrap"]
----
React4xp.CLIENT.render(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#render

React4xp.CLIENT.hydrate(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#hydrate

React4xp.CLIENT.renderWithDependencies(componentsTargetsAndProps, callback, serviceUrlRoot);
----

The first two methods are 'pure' renderers. This means that in addition to the client wrapper, you need to supply and run scripts for React and ReactDOM (which are bundled in the React4xp _externals_) - and scripts for the entries as well as all their chunks, before calling `render` or `hydrate`.

However, you can also use React4xp components in a standalone html page, having only React/ReactDOM (or React4xp externals) and this client loaded in the browser: use `renderWithDependencies` as below.

{nbsp} +

=== render and hydrate
They both have a `(Component, targetId [, props])` signature:

  * `Component`: _(React4xp entry or any ReactDOM renderable, mandatory)_ If it's a function, the wrapper will try to turn it into a ReactDOM component by running `Component(props)`. When loading React4xp entries, they are exposed in the client as functions as part of the `React4xp` object: `React4xp[jsxPath] = (props) => Component`. A fallback has been added so that if an entry component has been compiled into a `.default` sub-attribute, the client can access the component both with and without the `default` field: if `React4xp.CLIENT.render(React4xp.myComponent.default, ...)` is strictly correct, then `React4xp.CLIENT.render(React4xp.MyComponent, ...)` will also work.
  * `targetId` _(string, mandatory)_ The unique ID of an HTML container element, into which the component will be rendered. Obviously, this must exist in the DOM when running.
  * `props`: _(object, optional)_ Top-level props that will be sent into the component. React4xp relies on serialization of this object, so _functions can't be passed in this way!_

{nbsp} +

=== renderWithDependencies
This wraps a whole chain of necessary steps: when the client has the wrapper available, you know where to contact the services (the prefix: their common URL before the service names), you have some React4xp components you want to render and know their jsxPaths and props, then `renderWithDependencies` will take care of all the gritty details needed for a client-side render, in a single call for multiple React4xp components:

  - contact the React4xp services,
  - determine what the entries' chunk dependencies are,
  - download and run those in parallel,
  - then download and run the entry scripts,
  - then run `render` on each of the entries,
  - all the time preventing duplicate downloads.

Parameters:

  * `componentsTargetsAndProps` _(object, mandatory)_ Object where each entry is similar to the `Component, targetId, [, props]` signature mentioned above: the *keys*  are jsxPath strings of React4xp entries. The *values* are objects that have a mandatory `targetId` string and an optional `props` object.
  * `callback` _(function, optional)_ This function is run after running `render`,
  * `serviceUrlRoot` _(string, optional)_ Root of the URL to the `/react4xp` and `/react4xp-dependencies` link:#_services[services]. For example, if they have the URLs `/_/service/my.app/react4xp/` and `/_/service/my.app/react4xp-dependencies/`, then `serviceRootUrl` should be `/_/service/my.app` (without a trailing slash). This is _sort of optional_: you can skip it if you define a constant `SERVICE_URL_ROOT` in global namespace before running  `renderWithDependencies` (see link:#_5_webapp[the Webapp example]). If you don't, it's a mandatory argument.


{nbsp} +
{nbsp} +



TRENGER MER OM:

- XP6/7
- KONSEPTER / TERMINOLOGI
	- ENTRIES
	- CHUNKS
	- JSXPATHS
	- DATA OBJECTS
- HOWTOS and GOTCHAS
	- BUILD WITH STARTER
	- IMPORT INTO YOUR PROJECT
	- CUSTOMIZATION
		- REACT VERSION
		- NASHORN POLYFILLING
		- WEBPACK
		- MANUALLY PROTECTING CONTENT STUDIO CLIENT IN EDIT/INLINE MODE
	- WEBAPP: CLIENT-SIDE STANDALONE

